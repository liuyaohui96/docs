
# regular_expression_docs
1. [转义](#转义)
2. [匹配单个字符](#匹配单个字符)
3. [匹配若干个相同类型字符](#匹配若干个相同类型字符)
4. [边缘匹配](#边缘匹配)
5. [或](#或)
6. [捕获和分组](#捕获和分组)
7. [先行断言 & 后行断言](#先行断言--后行断言)



## 转义
* 匹配 `^ $ * + ? { | [ . () \` 这些字符需要使用 `\` 作为前缀
* \r  => 匹配回车
* \n => 匹配换行
* \t => tab

[回到顶部](#regular_expression_docs)




## 匹配单个字符
1. 特殊字符指定单个字符
    ```javascript
    /./   // 匹配单个字符除了\r \n（换行符）, 相当于[^\n\r]
    
    /\d/  // 匹配数字，相当于[0-9]
    /\D/  // 匹配非数，相当于[^0-9]
    

    /\w/   // 匹配字母，数字，下划线，相当于[a-zA-Z0-9]
    /\w/  // 相当于 [^a-zA-Z0-9_]

   

    /\s/   // 匹配所有空白字符，包括
    /\S/   // 匹配所有非空格字符
    ```
2. 自定义匹配单个字符
    ```javascript
    /a/  // 单个字符，a-z A-z 数字或这其他转义字符

    /[aeiou]/ // 匹配aeiou中的一个

    /[^aeiou]/ // 匹配非aeiou中的一个，^取反

    /[a-z]/ // 范围匹配其中一个

    /[a-zA-Z]/ // 匹配字母

    /[^a-zA-Z]/ // 匹配非字母

    // 在集合中， . + *  | () $ {} 没有特殊含义
    // ^在[]中有意义，表示取反
    [+] // 返回字符串中任何 + 字符的匹配项
    ```

[回到顶部](#regular_expression_docs)



## 匹配若干个相同类型字符
1. 特殊字符匹配若干个相同类型字符
    ```js
    /a?/   // 匹配0到1个a, 相当于/a{0,1}/

    /a*/   // 匹配0到多个a 相当于/a{0,}

    /a+/   // 匹配1到多个a 相当于/a{1,}/

    // 由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串
    [a-zA-Z\_][0-9a-zA-Z\_]*
    ```
2. 自定义匹配若干个相同类型字符，使用`{m, n}`
    ```javascript
    /a{3}/ // 匹配3个a

    /a{3,}/ // 匹配至少三个a

    // 前面1个字符+后面最多19个字符
    [a-zA-Z\_][0-9a-zA-Z\_]{0, 19}
    ```
3. `* + {}` 属于贪婪匹配，尽可能的蔓延匹配
    ```js
    /a.*a/  
    // === 例子
    字符串: <p>hello</p>

    /<.+>/     // 结果为 <p>hello</p>
    /<.*>/    // 结果为 <p>hello</p>
    /<.+>?/   // 结果为<p>
    /<[^<>]+>/g  // 结果为  <p> </p>
    ```
4. 懒匹配 `*?` : 尽可能少的匹配前面的字符
    ```js
    a*? // Matches as few characters as possible.

    // === 例子
    字符串：r re regex
    /r\w*?/g  // 返回 r r r

    ```

[回到顶部](#regular_expression_docs)


## 边缘匹配
1. 开始和结束字符匹配
    ```javascript
    /^abc/   // 匹配abc开始，相当于/\Aabc/

    /abc$/   // 匹配abc结束，相当于/abc\Z/
    ```
2. 边缘匹配：边缘时指在单词的开头或末尾的匹配项
    ```js
    /a\b/ // 匹配在边缘（boundary）的a

    /a\B/ // 匹配不在边缘（boudary）的a
    ```

[回到顶部](#regular_expression_docs)




## 或
```js
/cats|dogs/  //匹配cats或dogs
```


[回到顶部](#regular_expression_docs)

## 捕获和分组
```js
()  // 捕获分组

(?:) // 不捕获分组

// === 例子
liuyaohui is a goodboy

/(liu)|(?:goodboy)/g 
// match1: liu
// match2: goodboy
// group1: liu

// 捕获后的分组
// ([liu])([yao]])\2\1
```


[回到顶部](#regular_expression_docs)


## 先行断言 & 后行断言
```js
/a(?=b)/ // 匹配后面紧跟b的a，但不匹配b

// 正向否定查找
a(?!b) // 匹配后面不紧跟b的a，但不匹配b

// 中间多一个<
(?<=a)b // 匹配前面有a的b，但不匹配a

// 反向否定查找
(?<!a)b  // 匹配前面没有a的b，但不匹配a
```

[回到顶部](#regular_expression_docs)




