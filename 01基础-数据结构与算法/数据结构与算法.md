
# 数据结构与算法
1. [程序设计](#程序设计)
2. [数据结构](#数据结构)
    1. [数据结构基础](#数据结构基础)
    2. [线性表](#线性表)
        1. [线性表基础](#线性表基础)
        2. [数组](#数组)
        3. [链表](#链表)
        4. [栈](#栈)
        5. [队列](#队列)
    3. [二叉树](#二叉树)
    4. [图](#图)
    5. [哈希表](#哈希表)
    6. [堆](#堆)
3. [算法](#算法)
    1. [算法基础](#算法基础)
    2. [排序算法](#排序算法)
        1. [冒泡排序](#冒泡排序)
        2. [插入排序](#插入排序)
        3. [快速排序](#快速排序)
    3. [搜索算法](#搜索算法)
    4. [分治算法](#分治算法)
    5. [贪心算法](#贪心算法)
    6. [动态规划](#动态规划)


## 程序设计
`程序设计 = 数据结构和算法`



[回到顶部](#数据结构与算法)


## 数据结构


[回到顶部](#数据结构与算法)

### 数据结构基础
数据结构：
1. 数据结构可以用四元组来表示`DataStructure = (D, L, S, O)` ，其中
    * D（Data）是数据元素，组成数据的基本单位
    * L（Logic）是逻辑结构，描述数据对象中，数据元素的相互关系
    * S（Storage）是存储结构，数据的逻辑结构在计算机上的存储形式
    * O（Operation）是规定的操作：增删改查，排序，遍历等，具体根据业务需求确定
2. 数据项，数据元素，数据对象，数据之间的关系：
    * 数据项，组成数据元素，是数据不可分割的最小单位。如人这个数据元素，可以有姓名，性别等数据项组成
    * 数据元素，组成数据的基本单位
    * 数据对象，性质相同的数据元素的集合，是数据的子集
    * 数据是描述客观事物，可以输入到计算机并能被计算机处理的符号集合。如整型、实型扽数值类型，可以进行数值计算；字符数据类型，可以进行非数值处理；图片，声音，视频等可以通过编码手段变为字符数据处理
3. 数据的逻辑结构分为：
    * 线性结构，数据元素存在一对一的关系
    * 树形结构，数据元素存在一对多的关系
    * 图形结构，数据元素存在多对多的关系
    * 集合结构，数据元素同属于同一集合
4. 数据的存储结构可以分为：
    * 顺序存储结构：数据元素存储在地址连续的存储单元里，数据的逻辑关系和物理关系是一致的
    * 链式存储结构：数据元素存放在任意的存储单元，存储单元可以是连续的，也可以是不连续的，数据元素的存储关系并不能反映其逻辑关系
5. 抽象数据类型（Abstract Datd Type）：抽象数据类型指一个数学模型以及定义在该模型上的操作，抽象数据类型将实际生活中的问题分解为规模小而容易处理的问题（问题分解），然后抽象建立一个数据模型（抽象）并将具体的实现过程隐藏起来（信息隐藏）


```c
// 抽象数据类型标准格式
ADT ADT_Name
Data
  // 数据逻辑关系定义
Operation
  // 操作1
  // 操作2
  // ...
endADT
```

[回到顶部](#数据结构与算法)






### 线性表



[回到顶部](#数据结构与算法)

#### 线性表基础
线性表：
1. 线性表（List）：零个或者多个数据元素的有限序列
    * 序列，数据元素之间是有顺序的，如果有多个元素，除了第一个数据元素没有前驱，最后一个元素没有后继，其他数据元素都有且只有一个前驱和后继
    * 数据元素之间的关系是一对一关系
2. 线性表顺序存储：用一段连续的存储单元依次存储线性表的数据元素，通常使用数组实现线性表的顺序存储结构，注意顺序存储结构中，线性表长度数动态变化的，随着插入和删除动态变化，数组长度一般而言是固定的
    * 线性表顺序存储结构中访问数据元素的时间复杂度：通过地址计算得到数据元素的存储地址，时间复杂度为`O(1)`，所以线性表顺序存储也称为随机存储
    * 线性表顺序存储结构中插入删除数据元素的时间复杂度：最好情况：在线性表最后一个位置插入删除元素；其他情况：所有的元素都要后移(插入)或者前移(删除)n，时间复杂度为`O(n)`；平均情况：每个位置选取概率是相等的，则平均移动的频率为`(1+n)*n/2/n = (1+n)/2`, 所以线性表顺序存储结构的插入删除时间复杂度为`O(n)`
3. 线性表的链式存储结构：用一组任意的存储单元存储线性表的数据元素，存储单元可以是连续的，也可以是不连续的，为了表示数据元素与后继数据元素的逻辑关系，不仅需要存储数据信息，还需要存储后继节点的存储地址信息
    * 线性表链式存储结构中访问数据元素的时间复杂度：`O(n)`
    * 线性表链式存储结构中插入删除数据元素的时间复杂度：历查找指定的i的前一个位置，时间复杂度是`O(n)`，插入或者删除元素，时间复杂度是`O(1)`
4. 线性表的顺序存储和链式存储的区别
    * 线性表的顺序存储存取数据元素的时间复杂度为`O(1)`, 可以快速存取任意位置的数据元素，不需要为存储数据元素的逻辑关系开辟另外的存储空间；插入和删除元素的时间复杂度为`O(n)`, 插入和删除需要移动大量元素
    * 线性表的链式存储查找数据元素的时间复杂度为`O(n)`, 在知道要操作的指针(地址)后，插入和删除数据元素的时间复杂度为`O(1)`
    * 应用场景选择：线性表需要频繁查找，很少进行插入和删除操作，采用顺序存储结构。线性表需要频繁进行插入和删除操作，适合采用链式存储（单链表）
5. 数组（Array）：形式是`[value, value, ....]`，数组占据连续内存，按照顺序存储，数组本身记忆第一个数据元素的地址，索引从0开始
    * 时间效率高（可以O(1)时间读写元素）：利用数组时间效率高的特点，可以用数组来实现简单的哈希表，数组小标存储key，数组值存储哈希表的value
    * 空间效率不是很好（如存储一个数字，也要为其他数据预先开辟内存空间），为了解决数组空间效率不高的问题，人们设计了动态数组。比如C++的vector
6. 数组操作：
    * 读取：查看索引所指的数据值
    * 查找：如检测是否包含在数组中
    * 插入：从数组中插入一个数据值
    * 删除：从数组中删除一个数据值
7. 链表（Link list）：形式是`head -> node -> node -> ... -> null`，其中每一个node是`node: {value, next}`，链表使用链式存储
8. 链表基本操作：
    * 读取：访问链表中间的一个数据元素，需要从起点（表头）开始迭代列表直到找到所需的数据元素
    * 查找：如检测是否包含在数组中
    * 插入：从链表中插入一个数据值
    * 删除：从链表中删除一个数据值




```c
// === 线性表的抽象数据类型
ADT List
Data
  // 线性表描述
Opearation
  // 初始化，建立一个空表
  initList(* L)
  // 判断表是否为空
  isListEmpty(L)
  // 清空表
  clearList(*L)
  // 返回第i个位置元素
  getElem(L, i)
  // 查找给定值的位置
  locateElem(L, e)
  // 插入表
  listInsert(*L, i, e)
  // 删除表
  listDelete(*L, i, *e)
  // 返回线性表的长度
  listLength(L)
// === 线性表的抽象数据类型


// 顺序存储结构地址计算
// 假设每个数据元素占用c个存储单元
// ai表示当前位置的其实地址，则
LOC(a(i+1)) = LOC(ai) + c
LOC(ai) = a1 + (i-1)*c
```

[回到顶部](#数据结构与算法)


#### 数组


[回到顶部](#数据结构与算法)


#### 链表


[回到顶部](#数据结构与算法)



#### 栈


[回到顶部](#数据结构与算法)



#### 队列


[回到顶部](#数据结构与算法)



### 二叉树



[回到顶部](#数据结构与算法)




### 图
图由节点（node）和边（edge）组成
* node：图中数据元素，在图结构中，不允许没有node
* edge：任意两个node之间的逻辑关系，边集可以是空的

有向图和无向图：
* 有向图（directed graph）：有箭头，节点关系是单向的
* 无向图（undirected graph）：没有箭头，节点关系是双向的


[回到顶部](#数据结构与算法)


### 哈希表


[回到顶部](#数据结构与算法)



### 堆


[回到顶部](#数据结构与算法)







## 算法


[回到顶部](#数据结构与算法)

### 算法基础
算法：
1. 算法：解决特定问题的有限步骤的描述，在计算机中表示为有限的指令序列，每个指令包含一个或多个的操作
2. 算法具备的要素：
    * 输入与输出：零个或者多个的输入；一个或者多个的输出，没有输出的算法没有意义
    * 基本操作、确定性与可行性：可描述为由若干语义明确的基本操作组成的指令序列，每一基本操作在对应的计算模型中都是可行的
    * 有穷性（finiteness）与正确性（correctness）：有穷性，在执行有限次基本操作之后终止并给出输出；正确性，输出还应该能够符合由问题本身在事先确定的条件
    * 鲁棒性（robustness）：尽可能充分地应对一些特殊输入的处理
    * 重用性：推广到其它场景
3. 算法的效率度量方法
    * 事后统计方法：根据设计好的测试程序和数据，对不同算法的程序的运行时间比较，从而确定算法效率的高低，需要指定测试程序和完成不同程序的编写，，比较复杂，一般不建议采用
    * 事前分析估算的方法，抛开计算机硬件和软件，采用的程序语言等因素，一般需要考量算法好坏和输入规模这两个因素
4. 算法时间复杂度（time complexity）：具体地，特定算法处理规模为n的问题所需的时间可记作T(n)
    * 处理问题的规模是算法时间成本的重要因素，将其中最长执行时间作为T(n)。忽略硬件平台和软件环境，将时间复杂度理解为算法中各条指令的执行时间之和，可以将将T(n)定义为算法所执行基本操作的总次数
    * 渐进分析（asymptotic analysis）：评价算法运行效率时，可以忽略处理小规模问题的场景，转而关注处理更大规模问题时的表现。即对于两个函数f(n)和g(n),当n大于给定的一个整数N，f(n)总是大于g(n)，那么f(n)的渐进增长快于g(n)
    * 大O记号（big-O notation）：假如存在`T(n) < c∙f(n) (c是常数，f(n)是函数)`，随着问题规模n增大，算法执行时间的增长率与f(n)的增长率相同，记作`T(n) = O(f(n))`
    * 根据大O记号，`对于任一常数c > 0，有O(f(n)) = O(c∙f(n))`即函数中的系数可以忽略等同于1；`对于任意常数a > b > 0，有O(n^a+ n^b) = O(n^a)`，即多项式中的低次项均可忽略，只需保留最高次项
    * 大Ω记号（big-omega notation）：对算法执行效率的乐观估计
    * 大θ记号（（big-theta notation）：对算法复杂度的准确估计
5. 常见的算法渐进复杂度
    * O(1)：常数级别
    * O(log n),对数时间，例如二分查找。
    * O(n)，线性时间，例如简单查找。
    * O(n * log n)，例如快速排序，一种速度较快的排序算法。
    * O(n^2)，例如选择排序，一种速度较慢的排序算法。
    * O(n!)，例如旅行商问题的解决方案，一种非常慢的算法
6. 空间复杂度（space complexity）：算法所需存储空间的多少
    * 很多时间关注时间复杂度，因为就渐进复杂度的意义而言，在任一算法的任何一次运行过程中所消耗的存储空间，都不会多于其间所执行基本操作的累计次数，时间复杂度本身就是空间复杂度的一个天然的上界

绘制一个包含16格的网格，假设每秒执行10次操作
| 算法         | 操作数         | 时间          |
| ------------ | -------------- | ------------- |
| O(log n)     | 4              | 0.4s          |
| O(n)         | 16             | 1.6s          |
| O(n * log n) | 64             | 6.4s          |
| O(n^2)       | 256            | 25.6          |
| O(n!)        | 20922789888000 | 2092278988800 |


```javascript
// 常数阶 O(1)
// 从n>=3个互异整数中，任取三个元素
// 除最大、最小者以外，输出常规元素
ordinaryElement(S[], n)
  任取三个元素x, y, z // 返三个元素亦必互异
  通过比较，对它们做排序 a<b<c //
  输出b
// 取3个元素O(3) 
// 三个元素比较O(3)
// 输出O(1)



// 常数阶 O(1)
int x = 10;
int y = x + 10;

// 线性阶O(n)
for(int i =0; i < n;i++)

// 对数阶 O(log2n)
int count =1;
for(int i =1; i< count; i++){
  count * = 2;
}

// 平方阶 O(n^2)
// for嵌套循环
```


[回到顶部](#数据结构与算法)


### 排序算法


#### 冒泡排序
如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可
以增加一个标志位 flag 来监测这种情况，经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为 𝑂(𝑛^2
) ；但当输入数组完全有序时，可达到
最佳时间复杂度 𝑂(𝑛) 。



算法特性
‧ 时间复杂度为 𝑂(𝑛2
)、自适应排序：各轮“冒泡”遍历的数组长度依次为 𝑛 − 1、𝑛 − 2、…、2、1 ，
总和为 (𝑛 − 1)𝑛/2 。在引入 flag 优化后，最佳时间复杂度可达到 𝑂(𝑛) 。
‧ 空间复杂度为 𝑂(1)、原地排序：指针 𝑖 和 𝑗 使用常数大小的额外空间。
‧ 稳定排序：由于在“冒泡”中遇到相等元素不交换


#### 插入排序


插入排序的优势：
1. 插入排序的时间复杂度为 𝑂(𝑛^2)
2. 优势：
    * 快速排序的时间复杂度为 𝑂(𝑛 log 𝑛)，尽管插入排序的时间复杂度更高，但在数据量较小的情况下，插入排序通常更快；快速排序这类 𝑂(𝑛 log 𝑛) 的算法属于基于分治策略的排序算法，往往包含更多单元计算操作，在数据量较小时，𝑛^2 和 𝑛 log 𝑛 的数值比较接近，复杂度不占主导地位，每轮中的单元操作数量起到决定性作用
    * 许多编程语言（例如 Java）的内置排序函数采用了插入排序，大致思路为：对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序
3. 冒泡排序、选择排序和插入排序的时间复杂度都为 𝑂(𝑛^2) ，但在实际情况中，插入排序的使用频率显著高于冒泡排序和选择排序，主要有以下原因：
    * 冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作
    * 插入排序基于元素赋值实现，仅需 1 个单元操作，冒泡排序的计算开销通常比插入排序更高
    * 选择排序在任何情况下的时间复杂度都为 𝑂(𝑛2) 。如果给定一组部分有序的数据，插入排序通常比选择排序效率更高。选择排序不稳定，无法应用于多级排序

[回到顶部](#数据结构与算法)



#### 快速排序
快速排序（quick sort）是一种基于分治策略的排序算法，运行高效，应用广泛


 算法特性
‧ 时间复杂度为 𝑂(𝑛 log 𝑛)、自适应排序：在平均情况下，哨兵划分的递归层数为 log 𝑛 ，每层中的总循
环数为 𝑛 ，总体使用 𝑂(𝑛 log 𝑛) 时间。在最差情况下，每轮哨兵划分操作都将长度为 𝑛 的数组划分为
长度为 0 和 𝑛−1 的两个子数组，此时递归层数达到 𝑛 ，每层中的循环数为 𝑛 ，总体使用 𝑂(𝑛2
) 时间。
‧ 空间复杂度为 𝑂(𝑛)、原地排序：在输入数组完全倒序的情况下，达到最差递归深度 𝑛 ，使用 𝑂(𝑛) 栈
帧空间。排序操作是在原数组上进行的，未借助额外数组。
‧ 非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。


快速排序为什么快：
出现最差情况的概率很低：虽然快速排序的最差时间复杂度为 𝑂(𝑛2
) ，没有归并排序稳定，但在绝大
多数情况下，快速排序能在 𝑂(𝑛 log 𝑛) 的时间复杂度下运行。
‧ 缓存使用效率高：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较
高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性。
‧ 复杂度的常数系数小：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与
“插入排序”比“冒泡排序”更快的原因类似



基准数优化：
快速排序在某些输入下的时间效率可能降低：举一个极端例子，假设输入数组是完全倒序的，由于我们选择
最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 𝑛 − 1、
右子数组长度为 0 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 0 ，分治策略失效，快速排序
退化为“冒泡排序”的近似形式

可以优化哨兵划分中的基准数的选取策略

可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），并将这三个候选
元素的中位数作为基准数。这样一来，基准数“既不太小也不太大”的概率将大幅提升



尾递归优化：在某些输入下，快速排序可能占用空间较多

[回到顶部](#数据结构与算法)

### 搜索算法



[回到顶部](#数据结构与算法)



### 分治算法



[回到顶部](#数据结构与算法)


### 贪心算法



[回到顶部](#数据结构与算法)



### 动态规划


[回到顶部](#数据结构与算法)


