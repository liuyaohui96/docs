

## 集合
集合：
1. 集合：不允许元素重复的数据结构

[回到顶部](#数据结构与算法)

### 广度优先搜索
广度优先搜索（breadth-first search，BFS），广度优先搜索可回答两类问题：
* 从节点a出发，是否具有节点b的路径
* 从节点a出发，到节点b的最短路径。这类问题称为最短路径问题题（shorterst-path problem）


[回到顶部](#数据结构与算法)

### 递归
递归的基线条件（base case）：递归结束的条件
递归的递归条件（recursive case）：递归条件


### 向量
数据结构是数据项以某种逻辑次序结构化的集合，划分为
* 线性结构
* 半线性结构
* 非线性结构


最为基本的线性结构统称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同进一步地将序列区分为向量（vector）和列表（list）
* 向量：向量中，所有数据项的物理存放位置与其逻辑次序完全吻合，此时的逻辑次序也称作秩
（rank）
* 列表：列表中，逻辑上相邻的数据项在物理上未必相邻，而是采用间接定址的方式通过封装后的位置（position）相互引用

[回到顶部](#数据结构与算法)

### 二分查找


### 快速排序
快速排序的性能高度依赖于选择的基准值，假设总是将第一个元素用作基准值，且要处
理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序
* 假设总是将第一个元素用作基准值，栈长为O(n)
* 假设总是将中间的元素用作基准值，栈长为O(log n)

实际上，在调用栈的每层都涉及O(n)个元素，因此整个算法需要的时间为O(n) * O(log n) = O(n log n)。这就是最佳情况

在最糟情况下，有O(n)层，因此该算法的运行时间为O(n) * O(n) = O(n^2)

平均情况，每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为O(n log n)


[回到顶部](#数据结构与算法)

### D&C
divide and conquer，分而治之
* 找出基线条件（base case）
* 不停的缩小规模，直到问题达到基线条件


> base case: 停止递归（循环）的条件
> recursive case：递归进行的条件

[回到顶部](#数据结构与算法)

### 散列函数
给任何数据散列函数，输出一个数字，即将输入映射到数字
* 散列函数总是将同样的输入映射到相同的数字
* 将不同的输入映射到不同的数字


散列表（散列映射、映射、字典和关联数组），使用散列函数来确定元素的存储位置

散列表适用于：
* 模拟映射关系
* 防止重复
* 缓存数据


散列函数冲突（collision）。散列函数很重要，最理想的情况是，散列函数将键均匀地映射到散列表的不同位置


在平均情况下，散列表执行各种操作的时间都为O(1)。O(1)被称为常量时间。最糟情况下，散列表所有操作的运行时间都为O(n)——线性时间。

在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此兼具两者的优点，但在最糟情况下，散列表的各种操作的速度都很慢，因此，在使用散列表时，避开最糟情况至关重要，为此，需要避免冲突。而要避免冲突，需要有：
* 较低的填装因子。`填装因子 = 散列表包含元素数/位置总数`，填装因子大于1意味着商品数量超过了数组的位
置数，一旦填装因子开始增大，就需要在散列表中添加位置，这被称为调整长度（resizing），通常将数组增长一倍。填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度
* 良好的散列函数。良好的散列函数让数组中的值呈均匀分布，糟糕的散列函数让值扎堆，导致大量的冲突

[回到顶部](#数据结构与算法)


### 其他
在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有
个直接前驱和一个直接后继。

树形结构中，每一层上的数据元素可能和下 层中多个元素相关，但只能和上一层中一个元素相关。



队列是一种先进先出（First In First Out，FIFO）的数据结构，而栈是一种后进先出（Last In 
First Out，LIFO）的数据结构


[回到顶部](#数据结构与算法)