## 视图
视图不会将数据保存到存储设备之中，而且也不会将数据保存到其他任何地方，实际上视图保存的是 SELECT 语句,从视图中读取数据时，视图会在内部执行该 SELECT 语句并创建出一张临时表。
* 从视图中读取数据时，视图会在内部执行该 SELECT 语句并创建出一张临时表
* 以将频繁使用的 SELECT 语句保存成视图，这样就不用每次都重新书写了。视图归根到底就是
SELECT 语句，所以视图中的数据会随着原表的变化自动更新

```SQL
CREATE VIEW <View> <view-column-list>
    AS <SELECT>;
<view-column-list>: \(<column-list>(,\s<column-list>)*\)

Note: <SELECT> 部分可以是基于视图的查询，这样就是多重视图应该尽量避免在视图
     的基础上创建视图，多重视图会降低 SQL 的性能。

-- 从试图中查询
SELECT <column-list> FROM <View>;

Note: 首先执行定义视图的 SELECT 语句,根据得到的结果，
      再执行在 FROM 子句中使用视图的 SELECT 语句
      
```

视图的限制：
* 定义视图时不能使用ORDER BY子句.视图和表一样，数据行都是没有顺序的
* 定义视图的 SELECT 语句能够满足某些条件，那么这个视图就可以被更新
    * SELECT 子句中未使用 DISTINCT
    * FROM 子句中只有一张表
    * 未使用 GROUP BY 子句和 HAVING 子句

    原因：如果原表可以更新，那么视图中的数据也可以更新。反之亦然，如果视图发生了改变，而原表没有
    进行相应更新的话，就无法保证数据的一致性。
    **视图和表需要同时进行更新，因此通过汇总得到的视图无法进行更新**

```CSS
-- 删除视图
DROP VIEW <view-list>;
<view-list>: <view>, (,\s<view>);
```


## 子查询
子查询就是一张一次性视图。子查询作为内层查询会首先执行。随着子查询嵌套层数的增加，SQL 语句会变得越来越难读懂，性能也会越来越差，应该尽量避免使用多层嵌套的子查询。。原则上子查询必须设定名称，尽量从处理内容的角度出发为子查询设定恰当的名称
```SQL
SELECT <column-list> FROM (<SELECT>) AS <select-name>;

-- ORACLE 中忽略AS
```

标量就是单一的意思。标量子查询则有一个特殊的限制，那就是必须而且只能返回 1 行 1列的结果,标量子查询就是返回单一值的子查询。标量子查询的书写位置并不仅仅局限于 WHERE 子句中，通常任何可以使用单一值的位置都可以使用。

## 关联子查询
在使用关联子查询时，需要在表所对应的列名之前加上表的别名，以`<Table>.<column>`的形式记述.作为比较对象的都是同一张 Product 表，为了进行区别，需要使用表别名。

在细分的组内进行比较时，需要使用关联子查询。关联子查询的关联条件不能写到外层查询之中，因为关联名称具有作用域
