
## JavaScript垃圾处理机制
C与C++等语言中，开发人员可以直接控制内存的申请和回收。但是在Java、C#、JavaScript语言中，变量的内存空间的申请和释放都由程序自己处理。即JavaScript 具有自动的垃圾处理机制。

垃圾回收有两种方法：标记清除、引用计数:
1. 标记清除（mark-and-sweep）。这是javascript中最常用的垃圾回收方式。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉它会去掉环境中的变量以及被环境中的变量引用的变量的标记，仍被标记的变量为准备删除的变量。

2. 引用计数。
    * 引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数，如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。
    * 当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。
    * 引用计数有个最大的问题： 循环引用
        ```js
        //  func 执行结束后，返回值为 undefined，
        // 所以整个函数以及内部的变量都应该被回收，
        // 但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收
        function func() {
          let obj1 = {};
          let obj2 = {};

          obj1.a = obj2; // obj1 引用 obj2
          obj2.a = obj1; // obj2 引用 obj1
        }
        ```


##  解除引用
解决循环引用的问题，最好是在不使用它们的时候手工将它们设为null，这也称为解除引用(dereferencing), 这一做法适用于大多数全局变量和全局对象的属性
```js
globalPerson = null; 
```