
## 原型链继承
原型链继承的原理：将子类构造函数的原型设置为父类构造函数的实例，这样子类可以通过`[[prototype]]`访问父类实例及父类原型链上属性和方法。

为什么是父类构造函数的实例
```js
function Foo(){}
function Bar(){}
function Baz(){}
Bar.prototype = Foo.prototype;
// 因为Baz的扩展需要，修改了Foo.prototype，对Bar.prototype也造成了影响
Foo.prototype = {}; 
Baz.prototype = Foo.prototype;
```

使用构造函数实例创建一个父类的对象作为子类的原型对象具有一定的副作用，因为Foo构造函数内可能会有一定的副作用。

## 修改构造函数原型实现继承的主要方法
1. Constructor.prototype
    * 优点：支持目前所有的浏览器，符合标准，并且充分利用JIST优化
    * 缺点：函数必须要被初始化，构造函数的初始化，可能会给生成对象带来并不想要的方

2. Object.create()
    * 优点：支持IE9 以上版本的浏览器。允许一次性地直接设置 `__proto__` 属性，以便浏览器能更好地优化对象。同时允许通过 Object.create(null) 来创建一个没有原型的对象。
    * 缺点：使用第二个参数的时候有可能成为一个性能黑洞，因为每个对象的描述符属性都有自己的描述对象。当以对象的格式处理成百上千的对象描述的时候，可能会造成严重的性能问题。

3. Object.setPrototypeOf()：设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象。
    * 注意：由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。如果关心性能，你应该避免设置一个对象的 `[[Prototype]]`。相反，应该使用 Object.create()来创建带有想要的`[[Prototype]]`的新对象

4. __proto__
    * 优点：支持IE11 以上版本的浏览器
    * 缺点：
        * 将` __proto__ `设置为非对象的值会静默失败，并不会抛出错误。
        * 在生产环境中使用这个方法，快速运行 Javascript 是不可能的，因为许多浏览器优化了原型，尝试在调用实例之前猜测方法在内存中的位置，但是动态设置原型干扰了所有的优化，甚至可能使浏览器为了运行成功，使用完全未经优化的代码进行重编译。
        * 不支持 IE10 及以下的浏览器版本。
