
## Etag
既然根据文件修改时间来决定是否缓存尚有不足，在 HTTP / 1.1 出现了 ETag 和If-None-Match

Etag 是response header，是资源的特定版本的标识符。为了解决文件修改时间不精确带来的问题，服务器和浏览器协商，响应报文返回ETag头部作为文件的唯一标识。ETag头部是一个对用户代理不透明的值，这意味着HTTP用户代理（例如浏览器）不知道该字符串代表什么，并且无法预测其值是什么。

如果Etag是响应头部的一部分，则客户端可以在下一次请求将`If-None-Match`，用于验证资源，服务器检查该ETag，并判断出该页面自上次客户端请求之后是否被修改。如果认为缓存没有过期，则返回304状态码，浏览器继续使用缓存；如果认为缓存过期，则返回新资源给浏览器

没有明确指定生成ETag值的方法。 通常，使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号。 例如，MDN使用wiki内容的十六进制数字的哈希值。
```shell
# ASCII字符串
ETag: "<etag_value>"

# 例子
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```
> 实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag




## If-None-Match
If-None-Match 是reqeust header

ETag 属性之间的比较采用的是弱比较算法，即两个文件除了每个比特都相同外，内容一致也可以认为是相同的。

> 请求头带上了if-modified-since和if-none-match两个字段，则先判断etag，再判断last-modified（If-None-Match 优先级更高）


## If-Match
If-Match 是 request header。在请求方法为 GET 和 HEAD 的情况下，服务器仅在请求的资源满足此首部列出的 ETag值时才会返回资源。而对于 PUT 或其他非安全方法来说，只有在满足条件的情况下才可以将资源上传

ETag 之间的比较使用的是强比较算法，即只有在每一个字节都相同的情况下，才可以认为两个文件是相同的